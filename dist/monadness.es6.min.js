/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(1));
	__export(__webpack_require__(2));
	__export(__webpack_require__(3));
	__export(__webpack_require__(4));
	//# sourceMappingURL=index.js.map

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const maybe_1 = __webpack_require__(2);
	const option_1 = __webpack_require__(3);
	class Either {
	    isLeft() { return false; }
	    isRight() { return false; }
	    getLeft() { throw new ReferenceError("This either is Right."); }
	    getRight() { throw new ReferenceError("This either is Left."); }
	    toMaybe() {
	        return maybe_1.Maybe.none();
	    }
	    toOption() {
	        return option_1.Option.none();
	    }
	    equals(other) {
	        if (this === other)
	            return true;
	        if (!other || other instanceof Either === false)
	            return false;
	        if (this.isRight() !== other.isRight())
	            return false;
	        if (this.isRight() && this.getRight() === other.getRight())
	            return true;
	        if (this.getLeft() && this.getLeft() === other.getLeft())
	            return true;
	        return false;
	    }
	    toJSON() {
	        return this.toObject();
	    }
	    toString() {
	        return JSON.stringify(this.toJSON());
	    }
	}
	exports.Either = Either;
	(function (Either) {
	    function left(left) {
	        return new Left(left);
	    }
	    Either.left = left;
	    function right(right) {
	        return new Right(right);
	    }
	    Either.right = right;
	    function nothing() {
	        return nothingEither;
	    }
	    Either.nothing = nothing;
	    function sequence(...eithers) {
	        const arr = [];
	        for (const i in eithers) {
	            if (eithers[i].isLeft()) {
	                return new Left(eithers[i].getLeft());
	            }
	            arr[i] = eithers[i].get();
	        }
	        return new Right(arr);
	    }
	    Either.sequence = sequence;
	    function traverse(f) {
	        return function (as) {
	            const arr = [];
	            for (const i in as) {
	                const r = f(as[i]);
	                if (r.isLeft()) {
	                    return new Left(r.getLeft());
	                }
	                arr[i] = r.get();
	            }
	            return new Right(arr);
	        };
	    }
	    Either.traverse = traverse;
	    function lift(partialFunction) {
	        return (...args) => {
	            try {
	                return Either.right(partialFunction.apply(partialFunction, args));
	            }
	            catch (err) {
	                return Either.left(err);
	            }
	        };
	    }
	    Either.lift = lift;
	    class Left extends Either {
	        constructor(left) {
	            super();
	            this.left = left;
	        }
	        map(f) {
	            return new Left(this.left);
	        }
	        fmap(f) {
	            return new Left(this.left);
	        }
	        applies(f) {
	            return function (mb) {
	                return new Left(this.left);
	            };
	        }
	        mbind(f) {
	            return new Left(this.left);
	        }
	        bimap(lf, rf) {
	            return new Left(lf(this.left));
	        }
	        cata(lf, rf) {
	            return lf(this.left);
	        }
	        flatten() {
	            return this;
	        }
	        isLeft() {
	            return true;
	        }
	        get() {
	            throw new ReferenceError("This either is Left.");
	        }
	        getLeft() {
	            return this.left;
	        }
	        getOrElse(f) {
	            return f();
	        }
	        getOrElseGet(right) {
	            return right;
	        }
	        getOrThrow(err) {
	            throw err || new ReferenceError("This either is Left.");
	        }
	        orElse(f) {
	            return f();
	        }
	        toObject() {
	            return { left: this.left };
	        }
	    }
	    Either.Left = Left;
	    class Right extends Either {
	        constructor(right) {
	            super();
	            this.right = right;
	        }
	        map(f) {
	            return new Right(f(this.right));
	        }
	        fmap(f) {
	            return f(this.right);
	        }
	        applies(f) {
	            return eb => eb.fmap(f(this.right));
	        }
	        mbind(f) {
	            return this.applies(a => (b) => b(a))(f);
	        }
	        bimap(lf, rf) {
	            return new Right(rf(this.right));
	        }
	        cata(lf, rf) {
	            return rf(this.right);
	        }
	        flatten() {
	            const val = this.get();
	            if (val instanceof Either) {
	                return val.flatten();
	            }
	            else {
	                return this;
	            }
	        }
	        isRight() {
	            return true;
	        }
	        get() {
	            return this.right;
	        }
	        getRight() {
	            return this.right;
	        }
	        getOrElse(f) {
	            return this.right;
	        }
	        getOrElseGet(right) {
	            return this.right;
	        }
	        getOrThrow() {
	            return this.right;
	        }
	        orElse(f) {
	            return this;
	        }
	        toMaybe() {
	            return maybe_1.Maybe.just(this.right);
	        }
	        toOption() {
	            return option_1.Option.some(this.right);
	        }
	        toObject() {
	            return { right: this.right };
	        }
	    }
	    Either.Right = Right;
	})(Either = exports.Either || (exports.Either = {}));
	const nothingEither = new Either.Left(void (0));
	//# sourceMappingURL=either.js.map

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const either_1 = __webpack_require__(1);
	class Maybe {
	    isDefined() {
	        return false;
	    }
	    isEmpty() {
	        return false;
	    }
	    toEither() {
	        return either_1.Either.left(new ReferenceError("This either is Left."));
	    }
	    equals(other) {
	        if (!other || other instanceof Maybe === false)
	            return false;
	        if (this === other)
	            return true;
	        if (this.isDefined() === false && other.isDefined() === false)
	            return true;
	        return this.isDefined() === other.isDefined() && this.get() === other.get();
	    }
	    toJSON() {
	        return this.toObject();
	    }
	    toString() {
	        return JSON.stringify(this.toJSON());
	    }
	}
	exports.Maybe = Maybe;
	(function (Maybe) {
	    function just(value) {
	        return new Just(value);
	    }
	    Maybe.just = just;
	    function none() {
	        return new None();
	    }
	    Maybe.none = none;
	    function nothing() {
	        return nothingMaybe;
	    }
	    Maybe.nothing = nothing;
	    function fromNull(value) {
	        if (value === null || value === undefined) {
	            return Maybe.none();
	        }
	        else {
	            return Maybe.just(value);
	        }
	    }
	    Maybe.fromNull = fromNull;
	    function sequence(...maybes) {
	        const arr = [];
	        for (const i in maybes) {
	            if (maybes[i].isEmpty()) {
	                return new None();
	            }
	            arr[i] = maybes[i].get();
	        }
	        return new Just(arr);
	    }
	    Maybe.sequence = sequence;
	    function traverse(f) {
	        return function (as) {
	            const arr = [];
	            for (const i in as) {
	                const r = f(as[i]);
	                if (r.isEmpty()) {
	                    return new None();
	                }
	                arr[i] = r.get();
	            }
	            return new Just(arr);
	        };
	    }
	    Maybe.traverse = traverse;
	    function lift(partialFunction) {
	        return (...args) => {
	            try {
	                return Maybe.just(partialFunction.apply(partialFunction, args));
	            }
	            catch (err) {
	                return Maybe.none();
	            }
	        };
	    }
	    Maybe.lift = lift;
	    class None extends Maybe {
	        constructor() {
	            super();
	        }
	        map(f) {
	            return new None();
	        }
	        fmap(f) {
	            return new None();
	        }
	        applies(f) {
	            return function (mb) {
	                return new None();
	            };
	        }
	        mbind(f) {
	            return new None();
	        }
	        flatten() {
	            return this;
	        }
	        isEmpty() {
	            return true;
	        }
	        get() {
	            throw new ReferenceError("This is option is None.");
	        }
	        getOrElse(f) {
	            return f();
	        }
	        getOrElseGet(value) {
	            return value;
	        }
	        getOrThrow(err) {
	            throw err || new ReferenceError("This option is None.");
	        }
	        orElse(f) {
	            return f();
	        }
	        toEither() {
	            return either_1.Either.left(new ReferenceError("This either is Left."));
	        }
	        toObject() {
	            return { just: null };
	        }
	    }
	    Maybe.None = None;
	    class Just extends Maybe {
	        constructor(value) {
	            super();
	            this.value = value;
	        }
	        map(f) {
	            return new Just(f(this.value));
	        }
	        fmap(f) {
	            return f(this.value);
	        }
	        applies(f) {
	            return mb => mb.fmap(f(this.value));
	        }
	        mbind(f) {
	            return this.applies(a => (b) => b(a))(f);
	        }
	        flatten() {
	            const val = this.get();
	            if (val instanceof Maybe) {
	                return val.flatten();
	            }
	            else {
	                return this;
	            }
	        }
	        isDefined() {
	            return true;
	        }
	        get() {
	            return this.value;
	        }
	        getOrElse(value) {
	            return this.value;
	        }
	        getOrElseGet(value) {
	            return this.value;
	        }
	        getOrThrow(err) {
	            return this.value;
	        }
	        orElse(o) {
	            return this;
	        }
	        toEither() {
	            return either_1.Either.right(this.value);
	        }
	        toObject() {
	            return { just: this.value };
	        }
	    }
	    Maybe.Just = Just;
	    const nothingMaybe = new None();
	})(Maybe = exports.Maybe || (exports.Maybe = {}));
	//# sourceMappingURL=maybe.js.map

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const either_1 = __webpack_require__(1);
	class Option {
	    isDefined() {
	        return false;
	    }
	    isEmpty() {
	        return false;
	    }
	    get() {
	        throw new ReferenceError("This is option is None.");
	    }
	    toEither() {
	        return either_1.Either.left(new ReferenceError("This either is Left."));
	    }
	    equals(other) {
	        if (!other || other instanceof Option === false)
	            return false;
	        if (this === other)
	            return true;
	        if (this.isDefined() === false && other.isDefined() === false)
	            return true;
	        return this.isDefined() === other.isDefined() && this.get() === other.get();
	    }
	    toJSON() {
	        return this.toObject();
	    }
	    toString() {
	        return JSON.stringify(this.toJSON());
	    }
	}
	exports.Option = Option;
	(function (Option) {
	    function some(value) {
	        return new Some(value);
	    }
	    Option.some = some;
	    function none() {
	        return new None();
	    }
	    Option.none = none;
	    function nothing() {
	        return nothingOption;
	    }
	    Option.nothing = nothing;
	    function lift(partialFunction) {
	        return (...args) => {
	            try {
	                return Option.some(partialFunction.apply(partialFunction, args));
	            }
	            catch (err) {
	                return Option.none();
	            }
	        };
	    }
	    Option.lift = lift;
	    class None extends Option {
	        constructor() {
	            super();
	        }
	        isEmpty() {
	            return true;
	        }
	        getOrElse(f) {
	            return f();
	        }
	        getOrElseGet(value) {
	            return value;
	        }
	        getOrThrow(err) {
	            throw err || new ReferenceError("This option is None.");
	        }
	        orElse(f) {
	            return f();
	        }
	        toEither() {
	            return either_1.Either.left(new ReferenceError("This either is Left."));
	        }
	        toObject() {
	            return { some: null };
	        }
	    }
	    Option.None = None;
	    class Some extends Option {
	        constructor(value) {
	            super();
	            this.value = value;
	        }
	        isDefined() {
	            return true;
	        }
	        get() {
	            return this.value;
	        }
	        getOrElse(value) {
	            return this.value;
	        }
	        getOrElseGet(value) {
	            return this.value;
	        }
	        getOrThrow(err) {
	            return this.value;
	        }
	        orElse(o) {
	            return this;
	        }
	        toEither() {
	            return either_1.Either.right(this.value);
	        }
	        toObject() {
	            return { some: this.value };
	        }
	    }
	    Option.Some = Some;
	    const nothingOption = new None();
	})(Option = exports.Option || (exports.Option = {}));
	//# sourceMappingURL=option.js.map

/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	function factory(...values) {
	    const tuple = values.slice(0);
	    Object.defineProperty(tuple, "length", { value: tuple.length });
	    for (let i = 0, len = tuple.length; i < len; i++) {
	        Object.defineProperty(tuple, `_${i + 1}`, { value: tuple[i] });
	    }
	    Object.defineProperty(tuple, "equals", {
	        value: function (other) {
	            if (this === other)
	                return true;
	            if (!other || "_1" in other === false)
	                return false;
	            if (this.length !== other.length)
	                return false;
	            for (let i = 0; i < this.length; i++) {
	                if (this[i].equals !== undefined && !this[i].equals(other[i])) {
	                    return false;
	                }
	                else if (this[i] !== other[i]) {
	                    return false;
	                }
	            }
	            return true;
	        },
	    });
	    Object.defineProperty(tuple, "toJSON", {
	        value: function () {
	            return this.slice(0).map((i) => !!i && i.toJSON !== undefined ? i.toJSON() : i);
	        },
	    });
	    Object.defineProperty(tuple, "toString", { value: function () { return JSON.stringify(this.toJSON()); } });
	    Object.defineProperty(tuple, "map", {
	        value: function (f) {
	            if (tuple.length === 0) {
	                return TUPLE_ZERO_SINGLETON;
	            }
	            const arr = new Array(tuple.length);
	            for (const i in tuple) {
	                arr[i] = f(tuple[i]);
	            }
	            return factory(...arr);
	        },
	    });
	    Object.defineProperty(tuple, "fmap", {
	        value: function (f) {
	            if (tuple.length === 0) {
	                return TUPLE_ZERO_SINGLETON;
	            }
	            const arr = new Array(tuple.length);
	            for (const i in tuple) {
	                arr[i] = f(tuple[i])[0];
	            }
	            return factory(...arr);
	        },
	    });
	    Object.defineProperty(tuple, "applies", {
	        value: function (f) {
	            return function (tb) {
	                if (tuple.length === 0) {
	                    return TUPLE_ZERO_SINGLETON;
	                }
	                const arr = new Array(tuple.length);
	                for (const i in tuple) {
	                    arr[i] = f(tuple[i])(tb[i])[0];
	                }
	                return factory(...arr);
	            };
	        },
	    });
	    Object.defineProperty(tuple, "mbind", {
	        value: function (f) {
	            if (tuple.length === 0) {
	                return TUPLE_ZERO_SINGLETON;
	            }
	            const arr = new Array(tuple.length);
	            for (const i in tuple) {
	                arr[i] = f[i](tuple[i])[0];
	            }
	            return factory(...arr);
	        },
	    });
	    return Object.freeze(tuple);
	}
	const TUPLE_ZERO_SINGLETON = factory();
	class Tuples {
	    constructor() { }
	    static from(...args) {
	        if (args.length === 0) {
	            return TUPLE_ZERO_SINGLETON;
	        }
	        return factory.apply(this, args);
	    }
	}
	exports.Tuples = Tuples;
	//# sourceMappingURL=tuples.js.map

/***/ }
/******/ ]);